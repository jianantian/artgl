# 关于渲染的概念模型

当我们认真做一件事情的时候，一开始就有必要好好的系统的了解这件事情到底是如何发生的，整个流程，体系是如何work的，而不是稀里糊涂的盲目尝试和做设计，这样总是事倍功半。

## 我们要做哪些封装和抽象？

原始的webgl是一个状态机，所以api的使用是不直观的，甚至说奇怪的。因为实际执行的效果，取决于状态机的状态，而这些状态，对于上层用户而言，过于晦涩和底层，非常易错，非常繁琐，因而需要封装和抽象，以有效的隔离复杂度。

当你bindbuffer， bufferdata， enablexxxarray， drawelement， 调用了一堆命令画一个东西，流程显得复杂，只要其中任何一个步骤不对，就不能完成正确的绘制。所以封装的直观意义在于，我只要调用1个命令，1个动作，就能完成之前很多行才能完成的画一个东西，另一个方面，至于这个东西画成什么样子，这个东西是什么样子，我应该把这个东西本身做一个封装，而不是散落在gl的一堆命令之中。对应起来：我们抽象封装的主要对象是**渲染的功能/命令**，和**渲染的资源**。

在web的环境下，用户能够创建多个canvas，创建多个不同的webglcontext， 所以成熟的webgl引擎，应该能做到一份数据能够在多个context下进行渲染。所以这就使得我们存在一个假设，用以创建context绑定的gl资源的数据， 不会在创建完gl资源结束后被释放，而是能够创建其他context的gl资源。用户本身持有这个数据，作为渲染内容的描述，而webgl引擎，负责资源的处理工作，这样的设计，能够向用户屏蔽gl资源创建和维护的流程，屏蔽多context的额外流程。

由上面的例子可以看出，渲染的资源/数据，具有一些区别的。我们讨论的资源，分为如下三种，第一种是所谓的**场景数据**，就是上文提到的用户本身持有的数据。第二种，是所谓的**gl资源**，gl资源的重要特点是context相关的，属于某一个context，由场景数据生成。第三种，是所谓**渲染数据**。关于渲染数据，可以理解为为了渲染而存在的中间数据，和gl没有关系，但是和渲染或者渲染的优化有直接的关系，对顶层用户是透明的。场景数据是描述了这个东西是什么，但是这个描述对应到实际的绘制命令，还有相当的距离。引擎会根据用户提供的场景数据，创建或者同步gl资源和渲染数据的更新，并使用它们进行实际的gl调用完成绘制过程。

## 用户场景数据

对于用户来说，关心的数据是场景的数据。 用户只能持有和访问场景数据。 场景数据是要么描述画什么，要么描述怎么画，场景数据结构，几乎等同于图形系统的API。如何设计场景数据，等于如何设计图形系统API。

理想的API应该是声明式的一个纯数据对象，图形系统直接从这个数据上确定怎么画和画什么的信息，用户修改场景数据，即产生效果。 糟糕的API是，用户可能不仅仅需要构造数据描述，还需要显式的调用图形系统的命令式接口，数据的构造，修改，和下层接口调用相互耦合和依赖。这种糟糕的设计会直接导致用户业务层代码的混乱，需要尽力避免。

### 关于描述画什么的场景数据

从用户的角度而言，一个最直观的接口就是一个数组，按绘制顺序描述了drawcall。用户每一帧都修改这个数组，或者不用改，丢给renderer就可以工作了。这种模式类似于display list，可以认为是最最基本的用户场景描述结构。 所以在提供给用户的renderer，我们提供renderList这样的接口用来支持这种最基本的场景描述。

在artgl中，renderer层和用户场景数据层唯一的接口其实就是renderList， 如果用户想要画一堆东西，他就需要构造renderList就可以了。这样设计的好处在于，整个用户数据的描述方式和渲染引擎是解耦的，用户可以自己构造，也可以使用另外的组件，例如场景树，场景图，来生成renderList， 总之，renderer只认识renderList。至于如何高效的生成和维护renderlist，那不是渲染引擎的任务。

所以我们暂且不讨论例如场景树之类的上层结构，还是围绕renderlist，为了保持自上而下的一致性，renderlist就是drawcalllist， 我们应该怎么描述每一个drawcall呢？ 在我们每画一个有意义的东西，而言，对于底层的工作，需要： 一堆attributes buffer来描述画的具体内容，一个program以及一堆uniform参数包括一堆gl参数描述如何去画。还有一堆uniform参数用来指定另一种画的内容（贴图）。 在artgl中，我们针对这三种底层资源设计了三种上层场景数据，Geometry， Technique， 和 Material。

